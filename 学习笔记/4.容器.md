容器是管理和存储数据集合的类模板，封装了动态数组、链表、树、哈希表等数据结构，并提供了统一的、经过优化的接口。STL 的一个核心思想就是，容器负责管理内存，而算法通过迭代器对容器中的数据进行操作。

# 分类
STL 容器主要分为四大类：
1. **序列式容器**：元素按严格的线性序列排序，用户可以控制每个元素的插入位置
2. **关联式容器**：元素根据其键值自动排序，插入位置由容器根据其内部排序规则决定
3. **无序关联式容器**：元素无特定顺序，根据其键值的哈希值组织在不同的桶 (bucket) 中，以实现快速查找
4. **容器适配器**：它们不是独立的容器，而是对上述容器的接口进行包装，以提供特定的行为（如 `stack`, `queue`）

# 底层算法结构
## 序列式容器

| 容器   | `vector` | `deque` | `list` | `array` |
| ---- | :------: | :-----: | :----: | :-----: |
| 底层结构 |   动态数组   | 分段的连续空间 |  双向链表  | C 风格数组  |
这些容器的底层结构相对而言都比较简单且只有它们自己使用，所以会融合入容器的实现中

## 关联式容器
**`set`**：键值就是实值，集合中**键值唯一**
**`multiset`**：允许**键值重复**的 `set`
**`std::map`**：存储 `<key, value>` 键值对，**键 (key) 唯一**
**`std::multimap`**：允许**键 (key) 重复**的 `map`

它们都基于**红黑树 (Red-Black Tree)** 这种自平衡二叉搜索树实现，所以需要将红黑树的实现剥离出一个独立的文件 `rb_tree.h`，不同容器只是对红黑树的不同封装

## 无序关联式容器
**`unordered_set`**、**`unordered_multiset`**、**`unordered_map`**、**`unordered_multimap`** 它们的作用和无 `unordered` 限制的关联式容器相同，区别在于元素顺序不确定，取决于哈希函数

类似的，底层实现依赖于独立的 `hashtable`

## 容器适配器
这里容器通常是对已有容器的封装，提供受限的接口来实现特定的数据结构
- **`std::stack` (栈)**：后进先出 (LIFO)。默认使用 `std::deque` 实现。只提供 `push()`, `pop()`, `top()` 等接口
- **`std::queue` (队列)**：先进先出 (FIFO)。默认使用 `std::deque` 实现。只提供 `push()`, `pop()`, `front()`, `back()` 等接口
- **`std::priority_queue` (优先队列)**：一个最大堆 (Max-Heap)，任何时候 `top()` 都是优先级最高的元素。默认使用 `std::vector` 实现，并通过 `std::make_heap`, `std::push_heap`, `std::pop_heap` 算法来维持堆的性质

# 如何选择合适的容器
- **需要频繁随机访问吗？**
    - **是** -> 首选 `std::vector`。如果还需要在头部快速增删，考虑 `std::deque`
- **主要操作是在序列两端增删吗？**
    - **是** -> `std::deque` 是最佳选择
- **需要频繁在序列中间插入/删除元素，并且关心迭代器稳定性吗？**
    - **是** -> `std::list`。它的代价是失去了随机访问能力
- **需要存储键值对，并按键排序或进行范围查找吗？**
    - **是** -> `std::map` / `std::multimap`
- **只需要快速查找、插入、删除，不关心元素顺序吗？**
    - **是** -> `std::unordered_map` / `std::unordered_set`。这是绝大多数场景下 `map`/`set` 的高性能替代品
- **只需要简单的 LIFO 或 FIFO 行为吗？**
    - **是** -> `std::stack` 或 `std::queue`